name: CI/CD - Test Application

'on':
  pull_request:
    branches:
      - main
      - feature/**
  push:
    branches:
      - main
      - feature/initial-implementation

jobs:
  # Backend API Tests
  backend-tests:
    name: Backend API Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: pgvector/pgvector:pg16
        env:
          POSTGRES_USER: bible
          POSTGRES_PASSWORD: bible123  # pragma: allowlist secret
          POSTGRES_DB: bibledb
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Python 3.12
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'
          cache: 'pip'
          cache-dependency-path: 'api/requirements.txt'

      - name: Install dependencies
        run: |
          cd api
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install ruff black mypy

      - name: Lint with Ruff
        run: |
          cd api
          ruff check . --select E,F,W,C90,I,N --ignore E501

      - name: Format check with Black
        run: |
          cd api
          black --check --diff .

      - name: Type check with MyPy
        run: |
          cd api
          mypy . --ignore-missing-imports --no-strict-optional

      - name: Run pytest
        env:
          DATABASE_URL: postgresql://bible:bible123@localhost:5432/bibledb  # pragma: allowlist secret
          LLM_PROVIDER: ollama
          OLLAMA_HOST: http://localhost:11434
        run: |
          cd api
          pytest -v --tb=short

      - name: Test API syntax and imports
        run: |
          cd api
          python -c "import main; import config; print('✓ Core modules import successfully')"
          python -c "from routes import chat, scripture; print('✓ Route modules import successfully')"
          python -c "from providers import factory; print('✓ Provider modules import successfully')"
          python -c "from scripture import repository, search; print('✓ Scripture modules import successfully')"

  # Frontend Tests
  frontend-tests:
    name: Frontend Tests
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [18.x, 20.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'

      - name: Install dependencies
        run: |
          cd frontend
          npm ci

      - name: Run unit tests
        run: |
          cd frontend
          npm run test:unit

      - name: Lint
        run: |
          cd frontend
          npm run lint

      - name: Type check
        run: |
          cd frontend
          npx tsc --noEmit

      - name: Build
        run: |
          cd frontend
          npm run build

  # Integration Tests
  # Only run after unit tests pass to save CI resources
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [backend-tests, frontend-tests]

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Create .env file
        run: | # pragma: allowlist secret
          # Create .env at root for docker compose
          # Matches production: OpenRouter for LLM, Ollama for embeddings
          # Using free Google Gemma model for cost-effective CI testing
          cat > .env << EOF
          LLM_PROVIDER=openrouter
          OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY }}
          OPENROUTER_MODEL=google/gemma-2-9b-it:free
          OLLAMA_HOST=http://ollama:11434
          EMBEDDING_PROVIDER=ollama
          EMBEDDING_MODEL=mxbai-embed-large
          DATABASE_URL=postgresql://bible:bible123@postgres:5432/bibledb  # pragma: allowlist secret
          EOF
          # Also copy to api folder
          cp .env api/.env

      - name: Start all services
        run: |
          docker compose up -d
          echo "Waiting for services to initialize..."
          sleep 30

      - name: Wait for Ollama to be ready
        run: |
          echo "Waiting for Ollama to pull embedding model (this may take a few minutes)..."
          max_attempts=60
          attempt=0
          until curl -sf http://localhost:11434/api/tags | grep -q "mxbai-embed-large"; do
            attempt=$((attempt + 1))
            if [ $attempt -eq $max_attempts ]; then
              echo "Ollama failed to be ready with embedding model"
              docker compose logs ollama
              exit 1
            fi
            echo "Waiting for Ollama embedding model... attempt $attempt/$max_attempts"
            sleep 10
          done
          echo "Ollama is ready with mxbai-embed-large embedding model!"
          echo "Note: Using OpenRouter for LLM (matches production config)"
          curl -s http://localhost:11434/api/tags | jq .

      - name: Test API health endpoint
        run: |
          max_attempts=30
          attempt=0
          until curl -f http://localhost:8000/health || [ $attempt -eq $max_attempts ]; do
            attempt=$((attempt + 1))
            echo "Waiting for API... attempt $attempt/$max_attempts"
            sleep 2
          done
          if [ $attempt -eq $max_attempts ]; then
            echo "API failed to start"
            docker compose logs api
            exit 1
          fi

      - name: Run all endpoint tests in parallel
        run: |
          # Create test scripts directory
          mkdir -p /tmp/tests

          # Test 1: Health & Config endpoints
          cat > /tmp/tests/test_health.sh << 'SCRIPT'
          #!/bin/bash
          set -e
          echo "=== Testing Health Endpoint ==="
          health_response=$(curl -sf http://localhost:8000/health)
          echo "$health_response" | jq .
          status=$(echo "$health_response" | jq -r '.status')
          if [ "$status" != "healthy" ]; then
            echo "ERROR: API status is $status (expected healthy)"
            exit 1
          fi
          echo "✓ Health endpoint OK"

          echo ""
          echo "=== Testing Config Endpoint ==="
          config_response=$(curl -sf http://localhost:8000/config)
          echo "$config_response" | jq .
          if echo "$config_response" | jq -e '.llm.provider' > /dev/null; then
            echo "✓ Config endpoint OK"
          else
            echo "ERROR: Config response missing expected fields"
            exit 1
          fi
          SCRIPT

          # Test 2: Scripture search endpoint
          cat > /tmp/tests/test_scripture.sh << 'SCRIPT'
          #!/bin/bash
          set -e
          echo "=== Testing Scripture Search Endpoint ==="
          search_response=$(curl -sf "http://localhost:8000/api/v1/scripture/search?q=love")
          echo "$search_response" | jq .
          echo "✓ Scripture search endpoint OK"
          SCRIPT

          # Test 3: Chat endpoint
          cat > /tmp/tests/test_chat.sh << 'SCRIPT'
          #!/bin/bash
          set -e
          echo "=== Testing Chat Endpoint ==="
          response=$(curl -sf -X POST http://localhost:8000/api/v1/chat \
            -H "Content-Type: application/json" \
            -d '{"message": "What does the Bible say about love?"}' \
            --max-time 180)
          echo "Chat response:"
          echo "$response" | jq .
          if echo "$response" | jq -e '.message' > /dev/null; then
            echo "✓ Chat endpoint responded successfully!"
          else
            echo "ERROR: Chat response missing 'message' field"
            exit 1
          fi
          SCRIPT

          # Test 4: Chat streaming endpoint
          cat > /tmp/tests/test_stream.sh << 'SCRIPT'
          #!/bin/bash
          echo "=== Testing Chat Streaming Endpoint ==="
          response=$(curl -sf -X POST http://localhost:8000/api/v1/chat/stream \
            -H "Content-Type: application/json" \
            -d '{"message": "Say hello"}' \
            --max-time 60 || true)
          if [ -n "$response" ]; then
            echo "Stream response received:"
            echo "$response" | head -c 500
            echo ""
            echo "✓ Chat streaming endpoint OK"
          else
            echo "WARNING: Streaming endpoint returned empty (may be expected)"
          fi
          SCRIPT

          # Test 5: Frontend health
          cat > /tmp/tests/test_frontend.sh << 'SCRIPT'
          #!/bin/bash
          set -e
          echo "=== Testing Frontend ==="
          max_attempts=30
          attempt=0
          until curl -sf http://localhost:3000 > /dev/null || [ $attempt -eq $max_attempts ]; do
            attempt=$((attempt + 1))
            echo "Waiting for Frontend... attempt $attempt/$max_attempts"
            sleep 2
          done
          if [ $attempt -eq $max_attempts ]; then
            echo "Frontend failed to start"
            exit 1
          fi
          echo "✓ Frontend OK"
          SCRIPT

          chmod +x /tmp/tests/*.sh

          # Run tests in parallel
          echo "Running all tests in parallel..."
          /tmp/tests/test_health.sh > /tmp/tests/health.log 2>&1 &
          pid_health=$!
          /tmp/tests/test_scripture.sh > /tmp/tests/scripture.log 2>&1 &
          pid_scripture=$!
          /tmp/tests/test_chat.sh > /tmp/tests/chat.log 2>&1 &
          pid_chat=$!
          /tmp/tests/test_stream.sh > /tmp/tests/stream.log 2>&1 &
          pid_stream=$!
          /tmp/tests/test_frontend.sh > /tmp/tests/frontend.log 2>&1 &
          pid_frontend=$!

          # Wait for all tests and collect results
          failed=0

          wait $pid_health || { echo "❌ Health test failed"; failed=1; }
          cat /tmp/tests/health.log

          wait $pid_scripture || { echo "❌ Scripture test failed"; failed=1; }
          cat /tmp/tests/scripture.log

          wait $pid_chat || { echo "❌ Chat test failed"; failed=1; }
          cat /tmp/tests/chat.log

          wait $pid_stream || { echo "❌ Stream test failed"; failed=1; }
          cat /tmp/tests/stream.log

          wait $pid_frontend || { echo "❌ Frontend test failed"; failed=1; }
          cat /tmp/tests/frontend.log

          if [ $failed -eq 1 ]; then
            echo ""
            echo "Some tests failed!"
            exit 1
          fi

          echo ""
          echo "✅ All tests passed!"

      - name: Show logs on failure
        if: failure()
        run: |
          echo "=== Ollama Logs ==="
          docker compose logs ollama
          echo "=== API Logs ==="
          docker compose logs api
          echo "=== Frontend Logs ==="
          docker compose logs frontend
          echo "=== PostgreSQL Logs ==="
          docker compose logs postgres

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v

  # Security & Dependencies Check
  security-check:
    name: Security & Dependency Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Check Python dependencies for vulnerabilities
        run: |
          cd api
          pip install safety
          safety check -r requirements.txt --ignore 70612
        continue-on-error: true

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: '20.x'

      - name: Check npm dependencies for vulnerabilities
        run: |
          cd frontend
          npm audit --audit-level=high
        continue-on-error: true
